MBCH File Renumbering Script Documentation
Purpose
This Python script is designed to re-number specific lines within .mbch files. It targets lines following the pattern c_att_(skill|names|ranks)_<NUMBER>. The re-numbering logic is based on sequential blocks and user-defined jumps, allowing for dynamic adjustment of the numbering scheme directly within the .mbch files using special comments.

Usage
You can run the script from your terminal using various methods:

Process all .mbch files in the current directory (default behavior):

python your_script_name.py

Process specific .mbch files:

python your_script_name.py file1.mbch file2.mbch

Process files matching a wildcard pattern:

python your_script_name.py \*.mbch

(Note: This is often redundant with the default if all .mbch files are in the current directory.)

Process files in a different directory (using full or relative paths):

python your_script_name.py /path/to/your/files/\*.mbch

Configuration (config.ini)
The script attempts to load configuration from a file named config.ini in the same directory where the script is executed. If config.ini does not exist, it will be created with default settings.

Example config.ini content:

[SETTINGS]
block_size_before_jump = 12

block_size_before_jump: This setting defines the default number of items in a logical block (e.g., 0-11 means 12 items) before a numbering jump would occur. This is a system-wide default.
However, this default value is overridden if an //PBADJUST comment is found within an .mbch file.

Dynamic Adjustment with //PBADJUST Comments
The most powerful feature of this script is its ability to dynamically adjust the re-numbering logic on a per-block basis within your .mbch files using a special comment: //PBADJUST X:Y:Z.

Place this comment on its own line, immediately before the block of c_att_ entries you wish to re-number with a specific pattern.

Format: //PBADJUST <block_size_idx>:<gap_size>:<ignored_value>

<block_size_idx> (X):
This is the zero-based index of the last entry in a logical block. The script calculates the total number of entries in this block as X + 1.

Example: If X = 11, the block contains 12 entries (indices 0 through 11).

Example: If X = 10, the block contains 11 entries (indices 0 through 10).

<gap_size> (Y):
This is the numerical amount added to the logical sequence number for each subsequent block of entries. This creates the "jump" in the numbering.

<ignored_value> (Z):
This third value is present in the comment format but is currently ignored by the script.

How the Renumbering Works (Logical vs. Final Numbers)
The script maintains a global_item_counter that tracks the logical sequence (0, 1, 2, 3...) of the c_att_skill_X triplets it encounters. When an //PBADJUST comment is found, this global_item_counter is reset to 0, and the new block_size_in_sequence and gap_size are applied for the subsequent c_att_ entries.

The calculate_new_block_number function then determines the "Final Number" for each c_att_ entry using the formula:
Final Number = Logical Sequence Number + (Group Number * gap_size)
Where Group Number = Logical Sequence Number // block_size_in_sequence

Examples of //PBADJUST in Action:
Scenario 1: Default behavior (12 entries per block, jump by 3)
(Equivalent to the script's default if no //PBADJUST is present, or by using //PBADJUST 11:3)

block_size_idx = 11 (meaning 0-11, total 12 entries)

gap_size = 3

Trace:

Logical 0-11 (1st block): 0-11 (Final Numbers are 0-11)

Logical 12 (start of 2nd block): 12 + (1 * 3) = 15 (Final Number is 15)

Logical 13: 13 + (1 * 3) = 16

...

Logical 23 (end of 2nd block): 23 + (1 * 3) = 26

Logical 24 (start of 3rd block): 24 + (2 * 3) = 30 (Final Number is 30)

Scenario 2: Your desired _10 followed by _15 (11 entries per block, jump by 4)
(This is achieved with //PBADJUST 10:4)

block_size_idx = 10 (meaning 0-10, total 11 entries)

gap_size = 4

Trace:

Logical 0-10 (1st block): 0-10 (Final Numbers are 0-10)

Logical 11 (start of 2nd block): 11 + (1 * 4) = 15 (Final Number is 15)

Logical 12: 12 + (1 * 4) = 16

...

Logical 21 (end of 2nd block): 21 + (1 * 4) = 25

Logical 22 (start of 3rd block): 22 + (2 * 4) = 30 (Final Number is 30)

Expected .mbch File Structure
The script expects c_att_ lines to appear in triplets:

c_att_skill_X
c_att_names_X
c_att_ranks_X

Where 'X' is the number to be re-indexed. The script identifies the start of a triplet by the _skill suffix. All three lines of a detected triplet will be re-numbered with the same calculated new number. Lines that do not match this pattern, or lines that are not part of a _skill led triplet, will be included in the output file without modification.

Error Handling
config.ini not found: The script will create a default config.ini file.

Invalid config.ini values: Warnings will be printed, and default values used.

File not found: An error message will be printed for missing files.

Empty files: A message indicating the file is empty will be printed, and processing skipped.

Broken triplet structure: If a _skill line is found but the subsequent _names or _ranks lines do not match the expected pattern, a warning will be printed, the original lines appended, and the script will attempt to continue processing.

Invalid numbers in //PBADJUST: A warning will be printed, and the current dynamic block/gap sizes will continue to be used.

Important Notes
The script overwrites the original files. It is highly recommended to backup your .mbch files before running the script.

Leading whitespace on c_att_ lines is preserved. Only trailing newlines are stripped during pattern matching.

The global_item_counter is reset to 0 every time an //PBADJUST comment is encountered. This allows you to define different re-numbering schemes for different sections of your file.